{
  "version": 3,
  "sources": ["../serviceWorker/createPacket.ts", "../serviceWorker/sw.ts"],
  "sourcesContent": ["/// <reference lib=\"WebWorker\" />\n\n\nconst IDENTIFIER_LENGTH = 32\nconst TYPE_LEGNTH = 1\nconst CONTENT_LENGTH = 16\nconst FLAGS = 8\nconst HEADER_LENGTH = IDENTIFIER_LENGTH + TYPE_LEGNTH + CONTENT_LENGTH + FLAGS\n\ntype MessageType = \"HEADER\" | \"BODY\"\n\n/*\n    | stream identifier (32 bits) | payload length (16 bits) | \n    | flags ( message type (1 bit)) (final message (1 bit))  | \n    | payload                                                |\n*/\nfunction createFrame(identifier: number, messageType: MessageType, payload: Uint8Array, finalMessage: boolean, sequenceNum: number) {\n\n    const headerSize = 11\n\n    let buffer = new ArrayBuffer(headerSize + payload.byteLength)\n    let view = new DataView(buffer);\n\n    view.setUint32(0, identifier)\n    view.setUint32(4, sequenceNum)\n    view.setUint16(8, payload.byteLength & 0xFFFF);\n\n\n    let flags = (messageType === \"HEADER\" ? 0 : 1) | ((finalMessage ? 1 : 0) << 1)\n\n    view.setUint8(10, flags)\n\n    let payloadView = new Uint8Array(buffer, headerSize);\n    payloadView.set(new Uint8Array(payload));\n\n    return buffer;\n}\n\n\nfunction createHeaderPacket(headers: Headers, currentIdentifier: number): ArrayBuffer {\n    // Create header packet\n    let formattedHeaders: Record<string, string> = {}\n\n    for (const header of headers.keys()) {\n        formattedHeaders[header] = headers.get(header)!\n    }\n\n    // TODO: come up with a more efficient header representation\n    const encodedHeader = new TextEncoder().encode(JSON.stringify(formattedHeaders))\n    const frame = createFrame(currentIdentifier, \"HEADER\", encodedHeader, true, 0);\n\n    return frame\n\n}\n\nconst packetSizeBytes = 16 * 1024\nconst payloadSize = packetSizeBytes - 7\n\nexport async function createPackets(request: Request, currentIdentifier: number, cb: (buf: ArrayBuffer) => void) {\n\n    cb(createHeaderPacket(request.headers, currentIdentifier))\n\n    // Make body packets\n    if (!request.body) {\n        return\n    }\n\n    const reader = request.body?.getReader()\n    if (!reader) {\n        console.log(request)\n        throw Error(\"Readable stream does not exist on reader\")\n    }\n\n    let frameNum = 0;\n\n    while (true) {\n        // Stream the body\n        const { done, value } = await reader?.read()\n        if (done) {\n            console.log(\"Last frame\")\n            const frame = createFrame(currentIdentifier, \"BODY\", new Uint8Array(), true, frameNum);\n            cb(frame); // Assuming cb is a callback function for handling each frame\n            break\n        }\n\n        if (!value) {\n            break\n        }\n\n        let readerPosition = 0\n        while (readerPosition < value.byteLength) {\n\n            const slicedArray = value.slice(readerPosition, readerPosition + payloadSize)\n\n            // check if last frame\n            let lastFrame = false;\n           \n\n            const frame = createFrame(currentIdentifier, \"BODY\", slicedArray, lastFrame, frameNum);\n            frameNum++\n            cb(frame)\n\n            readerPosition += payloadSize\n        }\n    }\n\n    return\n}", "/// <reference lib=\"WebWorker\" />\n\nimport { createPackets } from \"./createPacket\";\n\n\nclass Deferred<T> {\n    promise: Promise<T>;\n    resolve: (value: T | PromiseLike<T>) => void = () => {};\n    reject: (reason?: any) => void = () => {};\n\n    constructor() {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nclass HTTPProxy {\n\n    // a list of requests\n    // { id: request }\n    requests: Record<number, Deferred<any>> = {}\n    currentIdentifier = 1\n    async makeRequest(request: Request): Promise<Response> {\n        // @ts-ignore\n        const clients = await self.clients.matchAll()\n\n        await createPackets(request, this.currentIdentifier, (frame) => {\n            // console.log(frame)\n            clients[0].postMessage(frame)\n\n        })\n\n        if (!clients[0]) {\n            return new Response()\n        }\n\n\n        const prom = new Deferred<Response>()\n\n        this.requests[this.currentIdentifier] = prom\n        this.currentIdentifier += 1\n\n        return prom.promise\n    }\n\n    handleRequest(reqObj: any) {\n        console.log(this.requests, reqObj)\n        // resolve promise with data\n        this.requests[reqObj.id].resolve(reqObj.body)\n    }\n\n}\n\nconst proxy = new HTTPProxy()\n\n\nself.addEventListener('install', (event) => {\n    console.log('Service Worker installing.');\n});\n\nself.addEventListener('activate', (event) => {\n    console.log('Service Worker activated.');\n});\n\nlet lastClient: string = \"\"\n\nself.addEventListener(\"fetch\", async (event) => {\n    console.log(event)\n\n    event.respondWith(\n        (async (): Promise<Response> => {\n\n            if (event.clientId !== lastClient) {\n                peerConnected = false\n                lastClient = event.clientId\n                console.log(\"Detected restart\")\n                return fetch(event.request)\n            }\n\n            if (!peerConnected) {\n                return fetch(event.request)\n            }\n\n            console.log(new URL(event.request.url).origin)\n            console.log(event.request)\n            console.log(event.request.headers.get(\"Content-Type\"))\n            console.log(new URL(event.request.url).pathname)\n\n            const timeout = new Promise<Response>((resolve, reject) => {\n                setTimeout(async () => {\n                    console.log(\"Timed out\")\n\n                    resolve(\n                        fetch(event.request)\n                    )\n                }, 300)\n            })\n\n            const body = proxy.makeRequest(event.request)\n\n            // TODO: better lifecycle management\n            const res = Promise.race([timeout, body])\n            return res\n\n            // console.log(atob(body))\n\n            // return new Response(JSON.parse(atob(body)))\n        })(),\n    );\n});\n\nvar peerConnected = false\n\nself.addEventListener(\"message\", (event) => {\n    console.log(`Message received: ${event.data}`);\n\n    if (event.data === \"connected\") {\n        peerConnected = true\n\n        return\n    }\n\n    if (event.data === \"disconnected\") {\n        peerConnected = false\n        return\n    }\n\n    // proxy.handleRequest(JSON.parse(event.data))\n});\n"],
  "mappings": "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",
  "names": []
}
