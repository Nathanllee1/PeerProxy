{
  "version": 3,
  "sources": ["../serviceWorker/createPacket.ts", "../serviceWorker/streamHandler.ts", "../serviceWorker/requestHandler.ts", "../serviceWorker/wsProxy.ts", "../serviceWorker/sw.ts"],
  "sourcesContent": ["/// <reference lib=\"WebWorker\" />\n\n\nconst IDENTIFIER_LENGTH = 32\nconst TYPE_LEGNTH = 1\nconst CONTENT_LENGTH = 16\nconst FLAGS = 8\nconst HEADER_LENGTH = IDENTIFIER_LENGTH + TYPE_LEGNTH + CONTENT_LENGTH + FLAGS\n\ntype MessageType = \"HEADER\" | \"BODY\"\n\n/*\n    | stream identifier (32 bits) | payload length (16 bits) | \n    | flags ( message type (1 bit)) (final message (1 bit))  | \n    | payload                                                |\n*/\nfunction createFrame(identifier: number, messageType: MessageType, payload: Uint8Array, finalMessage: boolean, sequenceNum: number) {\n\n    const headerSize = 11\n\n    let buffer = new ArrayBuffer(headerSize + payload.byteLength)\n    let view = new DataView(buffer);\n\n    view.setUint32(0, identifier)\n    view.setUint32(4, sequenceNum)\n    view.setUint16(8, payload.byteLength & 0xFFFF);\n\n\n    let flags = (messageType === \"HEADER\" ? 0 : 1) | ((finalMessage ? 1 : 0) << 1)\n\n    view.setUint8(10, flags)\n\n    let payloadView = new Uint8Array(buffer, headerSize);\n    payloadView.set(new Uint8Array(payload));\n\n    return buffer;\n}\n\n\nfunction createHeaderPacket(request: Request, currentIdentifier: number): ArrayBuffer {\n    // Create header packet\n    let formattedHeaders: Record<string, string> = {}\n\n    for (const header of request.headers.keys()) {\n        formattedHeaders[header] = request.headers.get(header)!\n    }\n\n    formattedHeaders[\"method\"] = request.method\n    formattedHeaders[\"url\"] = new URL(request.url).pathname\n\n    // TODO: come up with a more efficient header representation\n    const encodedHeader = new TextEncoder().encode(JSON.stringify(formattedHeaders))\n    const frame = createFrame(currentIdentifier, \"HEADER\", encodedHeader, true, 0);\n\n    return frame\n\n}\n\nconst packetSizeBytes = 16 * 1024\nconst payloadSize = packetSizeBytes - 7\n\nexport async function createPackets(request: Request, currentIdentifier: number, cb: (buf: ArrayBuffer) => void) {\n    cb(createHeaderPacket(request, currentIdentifier))\n\n    // Make body packets\n    if (!request.body) {\n        const endFrame = createFrame(currentIdentifier, \"BODY\", new Uint8Array(), true, 0);\n        // console.log(endFrame)\n        cb(endFrame)\n        return\n    }\n\n    const reader = request.body?.getReader()\n    console.log(reader)\n    if (!reader) {\n        console.log(request)\n        \n        throw Error(\"Readable stream does not exist on reader\")\n    }\n\n    let frameNum = 0;\n\n    while (true) {\n        // Stream the body\n        const { done, value } = await reader?.read()\n        console.log(done)\n        if (done) {\n            console.log(\"Last frame\")\n            const frame = createFrame(currentIdentifier, \"BODY\", new Uint8Array(), true, frameNum);\n            cb(frame); // Assuming cb is a callback function for handling each frame\n            break\n        }\n\n        if (!value) {\n            break\n        }\n\n        let readerPosition = 0\n        while (readerPosition < value.byteLength) {\n\n            const slicedArray = value.slice(readerPosition, readerPosition + payloadSize)\n\n            // check if last frame\n            let lastFrame = false;\n\n\n            const frame = createFrame(currentIdentifier, \"BODY\", slicedArray, lastFrame, frameNum);\n            frameNum++\n            cb(frame)\n\n            readerPosition += payloadSize\n        }\n    }\n\n\n    return\n}\n\nexport type Packet = {\n    identifier: number\n    sequenceNum: number\n    payload: Uint8Array\n    messageType: \"HEADER\" | \"BODY\",\n    finalMessage: boolean\n};\n\nexport function parsePacket(buffer: ArrayBuffer): Packet {\n    // console.log(buffer)\n    const headerSize = 11;\n    let view = new DataView(buffer);\n\n    // Read the values from the buffer\n    let identifier = view.getUint32(0);\n    let sequenceNum = view.getUint32(4);\n    let payloadLength = view.getUint16(8);\n    let flags = view.getUint8(10);\n\n    const flagCodes = {\n        0: [false, false],\n        1: [false, true],\n        2: [true, false],\n        3: [true, true]\n    }\n\n    const [finalMessage, messageType] = flagCodes[flags]\n\n    // Extract the payload\n    let payload = new Uint8Array(buffer, headerSize, payloadLength);\n\n    // Construct the JSON object\n    return {\n        identifier,\n        sequenceNum,\n        payload,\n        messageType: messageType ? \"HEADER\" : \"BODY\",\n        finalMessage,\n    };\n}", "import { Packet } from \"./createPacket\"\n\nexport class CustomStream {\n\n    controller: ReadableStreamDefaultController\n    stream: ReadableStream\n\n    lastPacketFound = false\n    lastPacketNum = 0\n    packetsIngested = 0\n\n    outOfOrderPackets = {}\n    currentPacketNum = 0\n\n    cancelled = false\n\n    constructor() {\n        // Keeping a reference to the stream controller\n\n        // Creating a readable stream with an underlying source object\n        this.stream = new ReadableStream({\n            start: (controller) => {\n                this.controller = controller;\n            },\n            pull: (controller) => {\n                // This is called when the consumer wants to read data\n                // You might not need to implement anything here if you're only pushing data manually\n                \n            },\n            cancel: (reason) => {\n                if (!this.stream.locked && this.controller) {\n                    this.controller.close();\n                }\n                console.log(`Stream cancelled, reason: ${reason}`);\n                this.outOfOrderPackets = {}\n\n                this.cancelled = true\n            }\n        });\n    }\n\n    // Method to add items to the stream\n    addItem(item: Packet) {\n        if (!this.controller) {\n            console.error(\"Stream controller is not initialized.\");\n        }\n\n        // ignore if stream is cancelled\n        if (this.cancelled) {\n            return\n        }\n\n        this.packetsIngested++;\n\n        if (item.finalMessage) {\n            // console.log(\"Final message\", item)\n            this.lastPacketFound = true\n            this.lastPacketNum = item.sequenceNum\n\n        }\n\n\n        // console.log(item, item.identifier, this.currentPacketNum)\n\n        if (item.sequenceNum == this.currentPacketNum) {\n            // console.log(\"enqueing\", item)\n            this.controller.enqueue(item.payload);\n            this.currentPacketNum ++\n        } else if (item.sequenceNum > this.currentPacketNum) {\n            // console.log(\"Out of order\")\n            this.outOfOrderPackets[item.sequenceNum] = item.payload\n        }\n\n        while (true) {\n\n            // console.log(this.outOfOrderPackets)\n\n            if (! (this.currentPacketNum in this.outOfOrderPackets)) {\n                break\n            }\n\n            console.log(\"Adding packet from out of order\",this.currentPacketNum)\n\n\n            this.controller.enqueue(this.outOfOrderPackets[this.currentPacketNum])\n            delete this.outOfOrderPackets[this.currentPacketNum]\n\n            this.currentPacketNum++\n\n        }\n\n        \n        if (this.packetsIngested === this.lastPacketNum + 1 && this.lastPacketFound && this.currentPacketNum === this.lastPacketNum + 1) {\n            console.log(\"Closing stream\", item)\n\n            this.closeStream()\n            \n        }\n\n        return\n\n\n    }\n\n    // Method to close the stream\n    closeStream() {\n        this.outOfOrderPackets = {}\n\n        if (this.controller) {\n            this.controller.close();\n        }\n    }\n}\n", "import { createPackets, parsePacket } from \"./createPacket\";\nimport { CustomStream } from \"./streamHandler\";\n\nclass Deferred<T> {\n    promise: Promise<T>;\n    resolve: (value: T | PromiseLike<T>) => void = () => { };\n    reject: (reason?: any) => void = () => { };\n\n    constructor() {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nexport class HTTPProxy {\n\n    // a list of requests\n    // { id: request }\n    requests: Record<number, Deferred<Response>> = {}\n\n    responses: Record<number, CustomStream> = {}\n\n    currentIdentifier = 1\n\n    reset() {\n        console.log(\"Resetting requests\")\n        this.requests = {}\n        this.responses = {}\n        this.currentIdentifier = 1\n    }\n\n    async makeRequest(request: Request, client: Client): Promise<Response> {\n\n        await createPackets(request, this.currentIdentifier, (frame) => {\n            // console.log(frame)\n            client.postMessage({payload: frame, type: \"data\"})\n\n        })\n\n        const prom = new Deferred<Response>()\n\n        this.requests[this.currentIdentifier] = prom\n        this.currentIdentifier += 1\n\n        return prom.promise\n    }\n\n    handleRequest(reqObj: ArrayBuffer) {\n        const packet = parsePacket(reqObj)\n\n        if (packet.messageType === \"BODY\") {\n            this.responses[packet.identifier].addItem(packet)\n\n            return\n        }\n\n        const parsedHeaders: Record<string, string[]> = JSON.parse(new TextDecoder().decode(packet.payload))\n        const headers = new Headers()\n\n        let statusText: string = \"200 OK\"\n        let status: number = 200\n\n        for (const headerKey in parsedHeaders) {\n\n            if (headerKey === \"status_code\") {\n                status = parseInt(parsedHeaders[headerKey][0])\n                continue\n            }\n\n            if (headerKey === \"status\") {\n                statusText = parsedHeaders[headerKey][0]\n                continue\n            }\n\n            headers.append(headerKey, parsedHeaders[headerKey].join(\",\"))\n        }\n\n        const body = new CustomStream()\n        this.responses[packet.identifier] = body\n\n        const response = new Response(body.stream, {\n            headers,\n            status,\n            statusText\n            \n        })\n\n        this.requests[packet.identifier].resolve(response)\n    }\n\n}", "export class WsHandler {\n    ws: WebSocket\n    serverId: string\n    client: Client\n    open = false\n\n    wsClosed = true\n\n    needsRestart = false\n\n    constructor(serverId: string, client: Client) {\n        const signalingServer = \"wss://peepsignal.fly.dev\"\n        this.serverId = serverId\n        this.ws = new WebSocket(`${signalingServer}/?role=client&id=${serverId}`)\n        \n        this.setNewClient(client)\n        this.ws.addEventListener(\"open\", () => {\n            this.open = true\n        })\n\n        this.ws.addEventListener(\"close\", () => {\n            this.needsRestart = true\n        })\n    }\n\n    // Returns when websocket is open\n    async ready() {\n\n        if (this.open) {\n            return\n        }\n\n        return new Promise<void>((resolve, reject) => {\n            this.ws.addEventListener(\"open\", () => {\n                resolve()\n            })\n        })\n    }\n\n    setNewClient(client: Client) {\n        this.client = client\n\n        this.ws.addEventListener(\"message\", (event) => {\n            client.postMessage({ type: \"signalingMessage\", payload: event.data })\n        })\n    }\n\n}", "/// <reference lib=\"WebWorker\" />\n\nimport { HTTPProxy } from \"./requestHandler\";\nimport { WsHandler } from \"./wsProxy\";\n\nconst proxy = new HTTPProxy()\n\nlet ws: WsHandler\n\nself.addEventListener('install', (event) => {\n    console.log('Service Worker installing.', self);\n\n    self.skipWaiting()\n});\n\nself.addEventListener('activate', function (e) {\n    //  self.registration.unregister()\n    console.log(\"Activating\")\n\n    self.clients.claim()\n});\n\nlet lastClient: string = \"\"\n\nself.addEventListener(\"fetch\", async (untypedEvent) => {\n\n    const event = untypedEvent as FetchEvent\n\n    event.respondWith(\n        (async (): Promise<Response> => {\n            // console.log(new URL(event.request.url).hostname)\n\n            if (event.clientId !== lastClient || !peerConnected) {\n                peerConnected = false\n                lastClient = event.clientId\n                console.log(\"Detected restart\")\n                return fetch(event.request)\n            }\n\n            const client = await self.clients.get(event.clientId)\n\n            if (!client || !peerConnected) {\n                return fetch(event.request)\n            }\n\n            const clientHostname = new URL(client.url).hostname\n\n            // iF the request is not for the proxy, fetch it normally\n            if (new URL(event.request.url).hostname !== clientHostname) {\n                return fetch(event.request)\n            }\n\n            // console.log(event.request)\n\n            const body = await proxy.makeRequest(event.request, client)\n\n            return body\n\n        })(),\n    );\n});\n\n\n\nvar peerConnected = false\n\nself.addEventListener(\"message\", async (event) => {\n    const clientObj = event.source as unknown as Client\n    const client = await self.clients.get(clientObj.id)\n\n    switch (event.data.type) {\n        case \"disconnected\":\n            console.log(\"Disconnected, resetting\")\n            peerConnected = false\n            proxy.reset()\n            break;\n        case \"ready\":\n            peerConnected = true;\n\n            client.postMessage({\n                type: \"ready\"\n            })\n\n            break;\n\n        case \"data\":\n            proxy.handleRequest(event.data.payload);\n            break;\n\n        case \"createWs\":\n\n            console.log(\"CLIENT\", client)\n\n            if (!ws || ws.serverId !== event.data.payload.serverId || ws.needsRestart) {\n                console.log(\"New WS\")\n                ws = new WsHandler(event.data.payload.serverId, client)\n            }\n            ws.setNewClient(client)\n            await ws.ready()\n\n            // Tell client ws is ready\n            client.postMessage({\n                type: \"createWs\",\n                payload: {\n                    reqId: event.data.payload.reqId\n                }\n            })\n\n            break;\n\n        case \"signalingMessage\":\n\n            // console.log(event.data.payload)\n\n            if (!ws) {\n                console.error(\"No ws connection\")\n            }\n\n            // console.log(ws)\n\n            ws.ws.send(event.data.payload)\n\n            break;\n\n\n    }\n\n});\n"],
  "mappings": "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",
  "names": []
}
