{
  "version": 3,
  "sources": ["../node_modules/cookie/index.js", "../serviceWorker/cookieManager.ts", "../serviceWorker/createPacket.ts", "../serviceWorker/streamHandler.ts", "../serviceWorker/requestHandler.ts", "../serviceWorker/sw.ts"],
  "sourcesContent": ["/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.partitioned) {\n    str += '; Partitioned'\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} val\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n", "import cookie from \"cookie\"\n\nclass Cookies {\n\n    cookies: Record<string, Record<string, string>> = {}\n\n    reservedHeaders = [\"domain\", \"encode\", \"expires\", \"httponly\", \"maxage\", \"partitioned\", \"path\"]\n\n    setCookie(cookieString: string) {\n        const parsedCookie = cookie.parse(cookieString)\n\n        for (const key in parsedCookie) {\n            if (this.reservedHeaders.includes(key.toLowerCase())) {\n                continue\n            }\n\n            this.cookies[key] = parsedCookie\n        }\n    }\n\n    getCookies(domain: string | undefined) {\n        return Object.keys(this.cookies)\n            \n        .map(name => cookie.serialize(name, this.cookies[name][name]))\n        .reduce((acc, storedCookie) => `${acc} ${storedCookie};`, \"\")\n    }\n\n    resetCookies() {\n        this.cookies = {}\n    }\n\n}\n\nexport const cookieManager = new Cookies()", "/// <reference lib=\"WebWorker\" />\n\nimport { cookieManager } from \"./cookieManager\"\n\nconst IDENTIFIER_LENGTH = 32\nconst TYPE_LEGNTH = 1\nconst CONTENT_LENGTH = 16\nconst FLAGS = 8\nconst HEADER_LENGTH = IDENTIFIER_LENGTH + TYPE_LEGNTH + CONTENT_LENGTH + FLAGS\n\ntype MessageType = \"HEADER\" | \"BODY\"\n\n/*\n    | stream identifier (32 bits) | payload length (16 bits) | \n    | flags ( message type (1 bit)) (final message (1 bit))  | \n    | payload                                                |\n*/\nexport function createFrame(identifier: number, messageType: MessageType, payload: Uint8Array, \n    finalMessage: boolean, sequenceNum: number, heartbeat: boolean = false, cancel: boolean = false) {\n\n    const headerSize = 11\n\n    let buffer = new ArrayBuffer(headerSize + payload.byteLength)\n    let view = new DataView(buffer);\n\n    view.setUint32(0, identifier)\n    view.setUint32(4, sequenceNum)\n    view.setUint16(8, payload.byteLength & 0xFFFF);\n\n\n    let flags = (messageType === \"HEADER\" ? 0 : 1) | \n        ((finalMessage ? 1 : 0) << 1) | \n        ((heartbeat ? 1 : 0) << 2) |\n        ((cancel ? 1 : 0) << 3)\n\n    view.setUint8(10, flags)\n\n    let payloadView = new Uint8Array(buffer, headerSize);\n    payloadView.set(new Uint8Array(payload));\n\n    return buffer;\n}\n\n\nfunction createHeaderPacket(request: Request, currentIdentifier: number): ArrayBuffer {\n    // Create header packet\n    let formattedHeaders: Record<string, string> = {}\n\n    for (const header of request.headers.keys()) {\n        formattedHeaders[header] = request.headers.get(header)!\n    }\n\n    if (request.credentials === \"include\" || request.credentials === \"same-origin\") {\n        const cookies = cookieManager.getCookies(new URL(request.url).hostname)\n\n        formattedHeaders[\"Cookie\"] = cookies\n    }\n\n\n    formattedHeaders[\"method\"] = request.method\n    formattedHeaders[\"url\"] = new URL(request.url).pathname + new URL(request.url).search + new URL(request.url).hash\n\n    // console.log(formattedHeaders)\n\n    // TODO: come up with a more efficient header representation\n    const encodedHeader = new TextEncoder().encode(JSON.stringify(formattedHeaders))\n    const frame = createFrame(currentIdentifier, \"HEADER\", encodedHeader, true, 0);\n\n    return frame\n\n}\n\nconst packetSizeBytes = 16 * 1024\nconst payloadSize = packetSizeBytes - 7\n\nexport async function createPackets(request: Request, currentIdentifier: number, cb: (buf: ArrayBuffer) => void) {\n    cb(createHeaderPacket(request, currentIdentifier))\n\n    // Make body packets\n    if (!request.body) {\n        const endFrame = createFrame(currentIdentifier, \"BODY\", new Uint8Array(), true, 0);\n        // console.log(endFrame)\n        cb(endFrame)\n        return\n    }\n\n    const reader = request.body?.getReader()\n    // console.log(reader)\n    if (!reader) {\n        console.log(request)\n\n        throw Error(\"Readable stream does not exist on reader\")\n    }\n\n    let frameNum = 0;\n\n    while (true) {\n        // Stream the body\n        const { done, value } = await reader?.read()\n        // console.log(done)\n        if (done) {\n            // console.log(\"Last frame\")\n            const frame = createFrame(currentIdentifier, \"BODY\", new Uint8Array(), true, frameNum);\n            cb(frame); // Assuming cb is a callback function for handling each frame\n            break\n        }\n\n        if (!value) {\n            break\n        }\n\n        let readerPosition = 0\n        while (readerPosition < value.byteLength) {\n\n            const slicedArray = value.slice(readerPosition, readerPosition + payloadSize)\n\n            // check if last frame\n            let lastFrame = false;\n\n\n            const frame = createFrame(currentIdentifier, \"BODY\", slicedArray, lastFrame, frameNum);\n            frameNum++\n            cb(frame)\n\n            readerPosition += payloadSize\n        }\n    }\n\n\n    return\n}\n\nexport type Packet = {\n    identifier: number\n    sequenceNum: number\n    payload: Uint8Array\n    messageType: \"HEADER\" | \"BODY\",\n    finalMessage: boolean\n};\n\nexport function parsePacket(buffer: ArrayBuffer): Packet {\n    // console.log(buffer)\n    const headerSize = 11;\n    let view = new DataView(buffer);\n\n    // Read the values from the buffer\n    let identifier = view.getUint32(0);\n    let sequenceNum = view.getUint32(4);\n    let payloadLength = view.getUint16(8);\n\n    const flagCodes = {\n        0: [false, false],\n        1: [false, true],\n        2: [true, false],\n        3: [true, true]\n    }\n    let flags = view.getUint8(10) as keyof typeof flagCodes;\n\n    const [finalMessage, messageType] = flagCodes[flags]\n\n    // Extract the payload\n    let payload = new Uint8Array(buffer, headerSize, payloadLength);\n\n    // Construct the JSON object\n    return {\n        identifier,\n        sequenceNum,\n        payload,\n        messageType: messageType ? \"HEADER\" : \"BODY\",\n        finalMessage,\n    };\n}", "import { Packet } from \"./createPacket\"\n\nexport class CustomStream {\n\n    controller: ReadableStreamDefaultController\n    stream: ReadableStream\n\n    lastPacketFound = false\n    lastPacketNum = 0\n    packetsIngested = 0\n\n    outOfOrderPackets = {}\n    currentPacketNum = 0\n\n    cancelled = false\n\n    constructor() {\n        // Keeping a reference to the stream controller\n\n        // Creating a readable stream with an underlying source object\n        this.stream = new ReadableStream({\n            start: (controller) => {\n                this.controller = controller;\n            },\n            pull: (controller) => {\n                // This is called when the consumer wants to read data\n                // You might not need to implement anything here if you're only pushing data manually\n                \n            },\n            cancel: (reason) => {\n                if (!this.stream.locked && this.controller) {\n                    this.controller.close();\n                }\n                console.log(`Stream cancelled, reason: ${reason}`);\n                this.outOfOrderPackets = {}\n\n                this.cancelled = true\n            }\n        });\n    }\n\n    // Method to add items to the stream\n    addItem(item: Packet) {\n        if (!this.controller) {\n            console.error(\"Stream controller is not initialized.\");\n        }\n\n        // ignore if stream is cancelled\n        if (this.cancelled) {\n            return\n        }\n\n        this.packetsIngested++;\n\n        if (item.finalMessage) {\n            this.lastPacketFound = true\n            this.lastPacketNum = item.sequenceNum\n\n        }\n\n        if (item.sequenceNum == this.currentPacketNum) {\n            this.controller.enqueue(item.payload);\n            this.currentPacketNum ++\n\n        } else if (item.sequenceNum > this.currentPacketNum) {\n            this.outOfOrderPackets[item.sequenceNum] = item.payload\n        }\n\n        while (true) {\n\n            if (! (this.currentPacketNum in this.outOfOrderPackets)) {\n                break\n            }\n\n\n            this.controller.enqueue(this.outOfOrderPackets[this.currentPacketNum])\n            delete this.outOfOrderPackets[this.currentPacketNum]\n\n            this.currentPacketNum++\n\n        }\n\n        \n        if (this.packetsIngested === this.lastPacketNum + 1 && this.lastPacketFound && this.currentPacketNum === this.lastPacketNum + 1) {\n            // console.log(\"Closing stream\", item)\n\n            this.closeStream()\n            \n        }\n\n        return\n\n\n    }\n\n    // Method to close the stream\n    closeStream() {\n        this.outOfOrderPackets = {}\n\n        if (this.controller) {\n            this.controller.close();\n        }\n    }\n}\n", "import { cookieManager } from \"./cookieManager\";\nimport { createFrame, createPackets, parsePacket } from \"./createPacket\";\nimport { CustomStream } from \"./streamHandler\";\n\nclass Deferred<T> {\n    promise: Promise<T>;\n    resolve: (value: T | PromiseLike<T>) => void = () => { };\n    reject: (reason?: any) => void = () => { };\n\n    constructor() {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nexport class HTTPProxy {\n\n    // a list of requests\n    // { id: request }\n    requests: Record<number, Deferred<Response>> = {}\n\n    responses: Record<number, CustomStream> = {}\n\n    currentIdentifier = 1\n\n    client: Client\n\n    reset() {\n        console.log(\"Resetting requests\")\n        this.requests = {}\n        this.responses = {}\n        // this.currentIdentifier = 1\n    }\n\n    async makeRequest(request: Request, client: Client): Promise<Response> {\n        // console.log(\"Requesting\", request.url, client.id)\n        this.client = client\n        \n        await createPackets(request, this.currentIdentifier, (frame) => {\n            client.postMessage({payload: frame, type: \"data\"})\n        })\n\n        const prom = new Deferred<Response>()\n\n        this.requests[this.currentIdentifier] = prom\n        this.currentIdentifier += 1\n\n        return prom.promise\n    }\n\n    cancelAllRequests() {\n        for (const id in this.requests) {\n            \n            this.requests[id].reject(\"Request cancelled\")\n\n            const cancelFrame = createFrame(parseInt(id), \"BODY\", new Uint8Array(), true, 0, false, true)\n\n            this.client.postMessage({\n                type: \"data\",\n                payload: cancelFrame\n            })\n\n        }\n        this.reset()\n    }\n\n    handleRequest(reqObj: ArrayBuffer) {\n        const packet = parsePacket(reqObj)\n\n        if (packet.messageType === \"BODY\") {\n\n            if (!this.responses[packet.identifier]) {\n                console.error(\"No response found for\", packet.identifier)\n                return\n            }\n\n            this.responses[packet.identifier].addItem(packet)\n\n            return\n        }\n\n        const parsedHeaders: Record<string, string[]> = JSON.parse(new TextDecoder().decode(packet.payload))\n        const headers = new Headers()\n\n        let statusText: string = \"200 OK\"\n        let status: number = 200\n\n        for (const headerKey in parsedHeaders) {\n\n            if (headerKey === \"status_code\") {\n                status = parseInt(parsedHeaders[headerKey][0])\n                continue\n            }\n\n            if (headerKey === \"status\") {\n                statusText = parsedHeaders[headerKey][0]\n                continue\n            }\n\n            if (headerKey === \"Set-Cookie\") {\n                console.log(\"Setting cookies\", parsedHeaders[headerKey])\n                for (const cookie of parsedHeaders[headerKey]) {\n\n                    console.log(\"Setting cookie\", cookie)\n                    \n                    cookieManager.setCookie(cookie) // This is the line that is causing the error;\n\n                    this.client.postMessage({\n                        type: \"set-cookie\",\n                        payload: cookie\n                    })\n\n                    // document.cookie = cookie\n\n                }\n                continue\n            }\n\n            headers.append(headerKey, parsedHeaders[headerKey].join(\",\"))\n        }\n\n        const body = new CustomStream()\n        this.responses[packet.identifier] = body\n\n        const response = new Response(body.stream, {\n            headers,\n            status,\n            statusText,\n            \n        })\n\n        this.requests[packet.identifier].resolve(response)\n    }\n\n}", "/// <reference lib=\"WebWorker\" />\n\nimport { HTTPProxy } from \"./requestHandler\";\nimport { WsHandler } from \"./wsProxy\";\n\nconst proxy = new HTTPProxy()\n\nlet ws: WsHandler\n\nself.addEventListener('install', (event) => {\n    console.log('Service Worker installing.', self);\n\n    console.log(event)\n\n    self.skipWaiting()\n});\n\nself.addEventListener('activate', function (e) {\n    //  self.registration.unregister()\n    console.log(\"Activating\")\n\n    self.clients.claim()\n\n});\n\nlet lastClient: string = \"\"\n\nconst iframeMode = true\n\nasync function timeout(ms: number, event: FetchEvent, client: Client) {\n    const timeout = new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(fetch(event.request))\n        }, ms)\n    })\n\n    return Promise.race([proxy.makeRequest(event.request, client)])\n}\n\n\nlet pageClient: Client\nasync function handleIframeRequest(event: FetchEvent, client: Client) {\n    // console.log({peerConnected})\n\n    if (!client) {\n        return fetch(event.request)\n    }\n\n    // console.log(client.frameType, event.request.url)\n\n\n    const clientHostname = new URL(client.url).hostname\n    if (new URL(event.request.url).hostname !== clientHostname) {\n        return fetch(event.request)\n    }\n\n    const isRootPage = event.request.headers.get(\"x-root-page\") ? true : false\n    // console.log(\"Rootpage?!!\", isRootPage)\n    if (isRootPage) {\n        pageClient = client\n\n        return proxy.makeRequest(event.request, client)\n    }\n\n    if (client.frameType === \"top-level\") {\n        return fetch(event.request)\n    }\n\n    const url = new URL(event.request.url)\n\n    if (url.pathname === \"/iframe.html\" || url.pathname === \"/iframeScript.js\") {\n        return fetch(event.request)\n    }\n\n    return proxy.makeRequest(event.request, pageClient)\n\n}\n\nself.addEventListener(\"fetch\", async (untypedEvent) => {\n\n    const event = untypedEvent as FetchEvent\n    // console.log(new URL(event.request.url).hostname)\n    event.respondWith(\n        (async (): Promise<Response> => {\n            const client = await self.clients.get(event.clientId)\n\n            return handleIframeRequest(event, client)\n\n\n        })(),\n    );\n});\n\n\n\nvar peerConnected = false\n\nself.addEventListener(\"message\", async (event) => {\n    const clientObj = event.source as unknown as Client\n    const client = await self.clients.get(clientObj.id)\n    // console.log(event, self.clients)\n    switch (event.data.type) {\n        case \"disconnected\":\n            console.log(\"Disconnected, resetting\")\n            peerConnected = false\n            proxy.reset()\n            break;\n        case \"ready\":\n            peerConnected = true;\n\n            client.postMessage({\n                type: \"ready\"\n            })\n\n            break;\n\n        case \"cancelRequests\":\n            console.log(\"Cancelling requests\")\n            proxy.cancelAllRequests()\n            break;\n\n        case \"data\":\n            proxy.handleRequest(event.data.payload);\n            break;\n    }\n\n});\n"],
  "mappings": "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",
  "names": ["decode", "cookie", "cookie"]
}
