{
  "version": 3,
  "sources": ["../serviceWorker/createPacket.ts", "../serviceWorker/streamHandler.ts", "../serviceWorker/requestHandler.ts", "../serviceWorker/sw.ts"],
  "sourcesContent": ["/// <reference lib=\"WebWorker\" />\n\n\nconst IDENTIFIER_LENGTH = 32\nconst TYPE_LEGNTH = 1\nconst CONTENT_LENGTH = 16\nconst FLAGS = 8\nconst HEADER_LENGTH = IDENTIFIER_LENGTH + TYPE_LEGNTH + CONTENT_LENGTH + FLAGS\n\ntype MessageType = \"HEADER\" | \"BODY\"\n\n/*\n    | stream identifier (32 bits) | payload length (16 bits) | \n    | flags ( message type (1 bit)) (final message (1 bit))  | \n    | payload                                                |\n*/\nfunction createFrame(identifier: number, messageType: MessageType, payload: Uint8Array, finalMessage: boolean, sequenceNum: number) {\n\n    const headerSize = 11\n\n    let buffer = new ArrayBuffer(headerSize + payload.byteLength)\n    let view = new DataView(buffer);\n\n    view.setUint32(0, identifier)\n    view.setUint32(4, sequenceNum)\n    view.setUint16(8, payload.byteLength & 0xFFFF);\n\n\n    let flags = (messageType === \"HEADER\" ? 0 : 1) | ((finalMessage ? 1 : 0) << 1)\n\n    view.setUint8(10, flags)\n\n    let payloadView = new Uint8Array(buffer, headerSize);\n    payloadView.set(new Uint8Array(payload));\n\n    return buffer;\n}\n\n\nfunction createHeaderPacket(request: Request, currentIdentifier: number): ArrayBuffer {\n    // Create header packet\n    let formattedHeaders: Record<string, string> = {}\n\n    for (const header of request.headers.keys()) {\n        formattedHeaders[header] = request.headers.get(header)!\n    }\n\n    formattedHeaders[\"method\"] = request.method\n    formattedHeaders[\"url\"] = new URL(request.url).pathname\n\n    // TODO: come up with a more efficient header representation\n    const encodedHeader = new TextEncoder().encode(JSON.stringify(formattedHeaders))\n    const frame = createFrame(currentIdentifier, \"HEADER\", encodedHeader, true, 0);\n\n    return frame\n\n}\n\nconst packetSizeBytes = 16 * 1024\nconst payloadSize = packetSizeBytes - 7\n\nexport async function createPackets(request: Request, currentIdentifier: number, cb: (buf: ArrayBuffer) => void) {\n    console.log('Creating packets')\n    cb(createHeaderPacket(request, currentIdentifier))\n\n    // Make body packets\n    if (!request.body) {\n        const endFrame = createFrame(currentIdentifier, \"BODY\", new Uint8Array(), true, 0);\n        console.log(endFrame)\n        cb(endFrame)\n        return\n    }\n\n    const reader = request.body?.getReader()\n    console.log(reader)\n    if (!reader) {\n        console.log(request)\n        \n        throw Error(\"Readable stream does not exist on reader\")\n    }\n\n    let frameNum = 0;\n\n    while (true) {\n        // Stream the body\n        const { done, value } = await reader?.read()\n        console.log(done)\n        if (done) {\n            console.log(\"Last frame\")\n            const frame = createFrame(currentIdentifier, \"BODY\", new Uint8Array(), true, frameNum);\n            cb(frame); // Assuming cb is a callback function for handling each frame\n            break\n        }\n\n        if (!value) {\n            break\n        }\n\n        let readerPosition = 0\n        while (readerPosition < value.byteLength) {\n\n            const slicedArray = value.slice(readerPosition, readerPosition + payloadSize)\n\n            // check if last frame\n            let lastFrame = false;\n\n\n            const frame = createFrame(currentIdentifier, \"BODY\", slicedArray, lastFrame, frameNum);\n            frameNum++\n            cb(frame)\n\n            readerPosition += payloadSize\n        }\n    }\n\n\n    return\n}\n\nexport type Packet = {\n    identifier: number\n    sequenceNum: number\n    payload: Uint8Array\n    messageType: \"HEADER\" | \"BODY\",\n    finalMessage: boolean\n};\n\nexport function parsePacket(buffer: ArrayBuffer): Packet {\n    console.log(buffer)\n    const headerSize = 11;\n    let view = new DataView(buffer);\n\n    // Read the values from the buffer\n    let identifier = view.getUint32(0);\n    let sequenceNum = view.getUint32(4);\n    let payloadLength = view.getUint16(8);\n    let flags = view.getUint8(10);\n\n    const flagCodes = {\n        0: [false, false],\n        1: [false, true],\n        2: [true, false],\n        3: [true, true]\n    }\n\n    const [finalMessage, messageType] = flagCodes[flags]\n\n    // Extract the payload\n    let payload = new Uint8Array(buffer, headerSize, payloadLength);\n\n    // Construct the JSON object\n    return {\n        identifier,\n        sequenceNum,\n        payload,\n        messageType: messageType ? \"HEADER\" : \"BODY\",\n        finalMessage,\n    };\n}", "import { Packet } from \"./createPacket\"\n\nexport class CustomStream {\n\n    controller: ReadableStreamDefaultController\n    stream: ReadableStream\n\n    lastPacketFound = false\n    lastPacketNum = 0\n    packetsIngested = 0\n\n    outOfOrderPackets = {}\n    currentPacketNum = 0\n\n    constructor() {\n        // Keeping a reference to the stream controller\n\n        // Creating a readable stream with an underlying source object\n        this.stream = new ReadableStream({\n            start: (controller) => {\n                this.controller = controller;\n            },\n            pull: (controller) => {\n                // This is called when the consumer wants to read data\n                // You might not need to implement anything here if you're only pushing data manually\n                \n            },\n            cancel: (reason) => {\n                if (!this.stream.locked && this.controller) {\n                    this.controller.close();\n                }\n                console.log(`Stream cancelled, reason: ${reason}`);\n            }\n        });\n    }\n\n    // Method to add items to the stream\n    addItem(item: Packet) {\n        if (!this.controller) {\n            console.error(\"Stream controller is not initialized.\");\n        }\n\n        this.packetsIngested++;\n\n        if (item.finalMessage) {\n            console.log(\"Final message\", item)\n            this.lastPacketFound = true\n            this.lastPacketNum = item.sequenceNum\n\n        }\n\n\n        // console.log(item, item.identifier, this.currentPacketNum)\n\n        if (item.sequenceNum == this.currentPacketNum) {\n            console.log(\"enqueing\", item)\n            this.controller.enqueue(item.payload);\n            this.currentPacketNum ++\n        } else if (item.sequenceNum > this.currentPacketNum) {\n            // console.log(\"Out of order\")\n            this.outOfOrderPackets[item.sequenceNum] = item.payload\n        }\n\n        while (true) {\n\n            // console.log(this.outOfOrderPackets)\n\n            if (! (this.currentPacketNum in this.outOfOrderPackets)) {\n                break\n            }\n\n            console.log(\"Adding packet from out of order\",this.currentPacketNum)\n\n\n            this.controller.enqueue(this.outOfOrderPackets[this.currentPacketNum])\n            delete this.outOfOrderPackets[this.currentPacketNum]\n\n            this.currentPacketNum++\n\n        }\n\n        \n        if (this.packetsIngested === this.lastPacketNum + 1 && this.lastPacketFound && this.currentPacketNum === this.lastPacketNum + 1) {\n            console.log(\"Closing stream\", item)\n\n            this.closeStream()\n            \n        }\n\n        return\n\n\n    }\n\n    // Method to close the stream\n    closeStream() {\n        if (this.controller) {\n            this.controller.close();\n        }\n    }\n}\n", "import { createPackets, parsePacket } from \"./createPacket\";\nimport { CustomStream } from \"./streamHandler\";\n\nclass Deferred<T> {\n    promise: Promise<T>;\n    resolve: (value: T | PromiseLike<T>) => void = () => { };\n    reject: (reason?: any) => void = () => { };\n\n    constructor() {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nexport class HTTPProxy {\n\n    // a list of requests\n    // { id: request }\n    requests: Record<number, Deferred<any>> = {}\n\n    responses: Record<number, CustomStream> = {}\n\n    currentIdentifier = 1\n    async makeRequest(request: Request): Promise<Response> {\n        // @ts-ignore\n        const clients = await self.clients.matchAll()\n\n        await createPackets(request, this.currentIdentifier, (frame) => {\n            console.log(frame)\n            clients[0].postMessage(frame)\n\n        })\n\n        if (!clients[0]) {\n            return new Response()\n        }\n\n\n        const prom = new Deferred<Response>()\n\n        this.requests[this.currentIdentifier] = prom\n        this.currentIdentifier += 1\n\n        return prom.promise\n    }\n\n    handleRequest(reqObj: ArrayBuffer) {\n        const packet = parsePacket(reqObj)\n\n        if (packet.messageType === \"BODY\") {\n            this.responses[packet.identifier].addItem(packet)\n\n            return\n        }\n\n        const parsedHeaders: Record<string, string[]> = JSON.parse(new TextDecoder().decode(packet.payload))\n        const headers = new Headers()\n\n        let statusText: string = \"200 OK\"\n        let status: number = 200\n\n        for (const headerKey in parsedHeaders) {\n\n            if (headerKey === \"status_code\") {\n                status = parseInt(parsedHeaders[headerKey][0])\n                continue\n            }\n\n            if (headerKey === \"status\") {\n                statusText = parsedHeaders[headerKey][0]\n                continue\n            }\n\n            headers.append(headerKey, parsedHeaders[headerKey].join(\",\"))\n        }\n\n        const body = new CustomStream()\n        this.responses[packet.identifier] = body\n\n        const response = new Response(body.stream, {\n            headers,\n            status,\n            statusText\n            \n        })\n\n        this.requests[packet.identifier].resolve(response)\n    }\n\n}", "/// <reference lib=\"WebWorker\" />\n\nimport { HTTPProxy } from \"./requestHandler\";\n\nconst proxy = new HTTPProxy()\n\n\nself.addEventListener('install', (event) => {\n    console.log('Service Worker installing.', self);\n\n    self.skipWaiting()\n});\n\nself.addEventListener('activate', function(e) {\n   //  self.registration.unregister()\n   console.log(\"Activating\")\n\n   self.clients.claim()\n  });\n\nlet lastClient: string = \"\"\n\nself.addEventListener(\"fetch\", async (untypedEvent) => {\n\n    const event = untypedEvent as FetchEvent\n\n\n    event.respondWith(\n        (async (): Promise<Response> => {\n            // console.log(new URL(event.request.url).hostname)\n\n\n            if (event.clientId !== lastClient) {\n                peerConnected = false\n                lastClient = event.clientId\n                console.log(\"Detected restart\")\n                return fetch(event.request)\n            }\n\n            // TODO: implement caching\n            if (await self.clients.get(event.clientId) !== undefined) {\n                const clientHostname = new URL((await self.clients.get(event.clientId)).url).hostname\n\n                if (new URL(event.request.url).hostname !== clientHostname) {\n                    return fetch(event.request)\n                }\n    \n            }\n           \n            if (event) {\n\n                if (!peerConnected) {\n                    return fetch(event.request)\n                }\n            }\n\n            console.log(event.request)\n\n            const body = await proxy.makeRequest(event.request)\n\n            return body\n\n        })(),\n    );\n});\n\nvar peerConnected = false\n\nself.addEventListener(\"message\", (event) => {\n\n    switch (event.data) {\n        case \"connected\":\n            peerConnected = true;\n            break;\n        case \"disconnected\":\n            peerConnected = false;\n            break;\n\n        default:\n            proxy.handleRequest(event.data);\n            break;\n    }\n});\n"],
  "mappings": "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",
  "names": []
}
